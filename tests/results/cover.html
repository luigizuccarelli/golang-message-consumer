
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">gitea-cicd.apps.aws2-dev.ocp.14west.io/cicd/trackmate-message-consumer/pkg/handlers/consumer-mock.go (79.8%)</option>
				
				<option value="file1">gitea-cicd.apps.aws2-dev.ocp.14west.io/cicd/trackmate-message-consumer/pkg/handlers/consumer.go (83.9%)</option>
				
				<option value="file2">gitea-cicd.apps.aws2-dev.ocp.14west.io/cicd/trackmate-message-consumer/pkg/validator/validate.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package handlers

import (
        "errors"
        "fmt"
        "sync"
        "sync/atomic"

        "github.com/Shopify/sarama"
        "github.com/microlib/simple"
)

// ErrorReporter is a simple interface that includes the testing.T methods we use to report
// expectation violations when using the mock objects.
type ErrorReporter interface {
        Errorf(string, ...interface{})
}

// ValueChecker is a function type to be set in each expectation of the producer mocks
// to check the value passed.
type ValueChecker func(val []byte) error

var (
        errProduceSuccess              error = nil
        errOutOfExpectations                 = errors.New("No more expectations set on mock")
        errPartitionConsumerNotStarted       = errors.New("The partition consumer was never started")
)

const AnyOffset int64 = -1000

type producerExpectation struct {
        Result        error
        CheckFunction ValueChecker
}

// Consumer implements sarama's Consumer interface for testing purposes.
// Before you can start consuming from this consumer, you have to register
// topic/partitions using ExpectConsumePartition, and set expectations on them.
type Consumer struct {
        l                  sync.Mutex
        t                  *simple.Logger
        config             *sarama.Config
        partitionConsumers map[string]map[int32]*PartitionConsumer
        metadata           map[string][]int32
}

// NewConsumer returns a new mock Consumer instance. The t argument should
// be the *testing.T instance of your test method. An error will be written to it if
// an expectation is violated. The config argument can be set to nil.
func NewConsumer(t *simple.Logger, config *sarama.Config) *Consumer <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = sarama.NewConfig()
        }</span>

        <span class="cov8" title="1">c := &amp;Consumer{
                t:                  t,
                config:             config,
                partitionConsumers: make(map[string]map[int32]*PartitionConsumer),
        }
        return c</span>
}

// ConsumePartition implements the ConsumePartition method from the sarama.Consumer interface.
// Before you can start consuming a partition, you have to set expectations on it using
// ExpectConsumePartition. You can only consume a partition once per consumer.
func (c *Consumer) ConsumePartition(topic string, partition int32, offset int64) (sarama.PartitionConsumer, error) <span class="cov8" title="1">{
        c.l.Lock()
        defer c.l.Unlock()

        if c.partitionConsumers[topic] == nil || c.partitionConsumers[topic][partition] == nil </span><span class="cov8" title="1">{
                c.t.Error(fmt.Sprintf("No expectations set for %s/%d", topic, partition))
                return nil, errOutOfExpectations
        }</span>

        <span class="cov8" title="1">pc := c.partitionConsumers[topic][partition]
        if pc.consumed </span><span class="cov0" title="0">{
                return nil, sarama.ConfigurationError("The topic/partition is already being consumed")
        }</span>

        <span class="cov8" title="1">if pc.offset != AnyOffset &amp;&amp; pc.offset != offset </span><span class="cov0" title="0">{
                c.t.Error(fmt.Sprintf("Unexpected offset when calling ConsumePartition for %s/%d. Expected %d, got %d.", topic, partition, pc.offset, offset))
        }</span>

        <span class="cov8" title="1">pc.consumed = true
        return pc, nil</span>
}

// Topics returns a list of topics, as registered with SetTopicMetadata
func (c *Consumer) Topics() ([]string, error) <span class="cov8" title="1">{
        c.l.Lock()
        defer c.l.Unlock()

        if c.metadata == nil </span><span class="cov0" title="0">{
                c.t.Error("Unexpected call to Topics. Initialize the mock's topic metadata with SetTopicMetadata.")
                return nil, sarama.ErrOutOfBrokers
        }</span>

        <span class="cov8" title="1">var result []string
        for topic := range c.metadata </span><span class="cov8" title="1">{
                result = append(result, topic)
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// Partitions returns the list of parititons for the given topic, as registered with SetTopicMetadata
func (c *Consumer) Partitions(topic string) ([]int32, error) <span class="cov8" title="1">{
        c.l.Lock()
        defer c.l.Unlock()

        if c.metadata == nil </span><span class="cov0" title="0">{
                c.t.Error("Unexpected call to Partitions. Initialize the mock's topic metadata with SetTopicMetadata.")
                return nil, sarama.ErrOutOfBrokers
        }</span>
        <span class="cov8" title="1">if c.metadata[topic] == nil </span><span class="cov0" title="0">{
                return nil, sarama.ErrUnknownTopicOrPartition
        }</span>

        <span class="cov8" title="1">return c.metadata[topic], nil</span>
}

func (c *Consumer) HighWaterMarks() map[string]map[int32]int64 <span class="cov0" title="0">{
        hwms := make(map[string]map[int32]int64, len(c.partitionConsumers))
        return hwms
}</span>

// Close implements the Close method from the sarama.Consumer interface. It will close
// all registered PartitionConsumer instances.
func (c *Consumer) Close() error <span class="cov8" title="1">{
        c.l.Lock()
        defer c.l.Unlock()

        for _, partitions := range c.partitionConsumers </span><span class="cov8" title="1">{
                for _, partitionConsumer := range partitions </span><span class="cov8" title="1">{
                        _ = partitionConsumer.Close()
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SetTopicMetadata sets the clusters topic/partition metadata,
// which will be returned by Topics() and Partitions().
func (c *Consumer) SetTopicMetadata(metadata map[string][]int32) <span class="cov8" title="1">{
        c.l.Lock()
        defer c.l.Unlock()

        c.metadata = metadata
}</span>

// ExpectConsumePartition will register a topic/partition, so you can set expectations on it.
// The registered PartitionConsumer will be returned, so you can set expectations
// on it using method chaining. Once a topic/partition is registered, you are
// expected to start consuming it using ConsumePartition. If that doesn't happen,
// an error will be written to the error reporter once the mock consumer is closed. It will
// also expect that the
func (c *Consumer) ExpectConsumePartition(topic string, partition int32, offset int64) *PartitionConsumer <span class="cov8" title="1">{
        c.l.Lock()
        defer c.l.Unlock()

        if c.partitionConsumers[topic] == nil </span><span class="cov8" title="1">{
                c.partitionConsumers[topic] = make(map[int32]*PartitionConsumer)
        }</span>

        <span class="cov8" title="1">if c.partitionConsumers[topic][partition] == nil </span><span class="cov8" title="1">{
                c.partitionConsumers[topic][partition] = &amp;PartitionConsumer{
                        t:         c.t,
                        topic:     topic,
                        partition: partition,
                        offset:    offset,
                        messages:  make(chan *sarama.ConsumerMessage, c.config.ChannelBufferSize),
                        errors:    make(chan *sarama.ConsumerError, c.config.ChannelBufferSize),
                }
        }</span>

        <span class="cov8" title="1">return c.partitionConsumers[topic][partition]</span>
}

// PartitionConsumer implements sarama's PartitionConsumer interface for testing purposes.
// It is returned by the mock Consumers ConsumePartitionMethod, but only if it is
// registered first using the Consumer's ExpectConsumePartition method. Before consuming the
// Errors and Messages channel, you should specify what values will be provided on these
// channels using YieldMessage and YieldError.
type PartitionConsumer struct {
        highWaterMarkOffset     int64 // must be at the top of the struct because https://golang.org/pkg/sync/atomic/#pkg-note-BUG
        l                       sync.Mutex
        t                       *simple.Logger
        topic                   string
        partition               int32
        offset                  int64
        messages                chan *sarama.ConsumerMessage
        errors                  chan *sarama.ConsumerError
        singleClose             sync.Once
        consumed                bool
        errorsShouldBeDrained   bool
        messagesShouldBeDrained bool
}

// AsyncClose implements the AsyncClose method from the sarama.PartitionConsumer interface.
func (pc *PartitionConsumer) AsyncClose() <span class="cov8" title="1">{
        pc.singleClose.Do(func() </span><span class="cov8" title="1">{
                close(pc.messages)
                close(pc.errors)
        }</span>)
}

// Close implements the Close method from the sarama.PartitionConsumer interface. It will
// verify whether the partition consumer was actually started.
func (pc *PartitionConsumer) Close() error <span class="cov8" title="1">{
        if !pc.consumed </span><span class="cov0" title="0">{
                pc.t.Error(fmt.Sprintf("Expectations set on %s/%d, but no partition consumer was started.", pc.topic, pc.partition))
                return errPartitionConsumerNotStarted
        }</span>

        <span class="cov8" title="1">if pc.errorsShouldBeDrained &amp;&amp; len(pc.errors) &gt; 0 </span><span class="cov0" title="0">{
                pc.t.Error(fmt.Sprintf("Expected the errors channel for %s/%d to be drained on close, but found %d errors.", pc.topic, pc.partition, len(pc.errors)))
        }</span>

        <span class="cov8" title="1">if pc.messagesShouldBeDrained &amp;&amp; len(pc.messages) &gt; 0 </span><span class="cov0" title="0">{
                pc.t.Error(fmt.Sprintf("Expected the messages channel for %s/%d to be drained on close, but found %d messages.", pc.topic, pc.partition, len(pc.messages)))
        }</span>

        <span class="cov8" title="1">pc.AsyncClose()

        var (
                closeErr error
                wg       sync.WaitGroup
        )

        wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()

                var errs = make(sarama.ConsumerErrors, 0)
                for err := range pc.errors </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>

                <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                        closeErr = errs
                }</span>
        }()

        <span class="cov8" title="1">wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer wg.Done()
                for range pc.messages </span>{<span class="cov8" title="1">
                        // drain
                }</span>
        }()

        <span class="cov8" title="1">wg.Wait()
        return closeErr</span>
}

// Errors implements the Errors method from the sarama.PartitionConsumer interface.
func (pc *PartitionConsumer) Errors() &lt;-chan *sarama.ConsumerError <span class="cov8" title="1">{
        return pc.errors
}</span>

// Messages implements the Messages method from the sarama.PartitionConsumer interface.
func (pc *PartitionConsumer) Messages() &lt;-chan *sarama.ConsumerMessage <span class="cov8" title="1">{
        return pc.messages
}</span>

func (pc *PartitionConsumer) HighWaterMarkOffset() int64 <span class="cov0" title="0">{
        return atomic.LoadInt64(&amp;pc.highWaterMarkOffset) + 1
}</span>

// YieldMessage will yield a messages Messages channel of this partition consumer
// when it is consumed. By default, the mock consumer will not verify whether this
// message was consumed from the Messages channel, because there are legitimate
// reasons forthis not to happen. ou can call ExpectMessagesDrainedOnClose so it will
// verify that the channel is empty on close.
func (pc *PartitionConsumer) YieldMessage(msg *sarama.ConsumerMessage) <span class="cov8" title="1">{
        pc.l.Lock()
        defer pc.l.Unlock()

        msg.Topic = pc.topic
        msg.Partition = pc.partition
        msg.Offset = atomic.AddInt64(&amp;pc.highWaterMarkOffset, 1)

        pc.messages &lt;- msg
}</span>

// YieldError will yield an error on the Errors channel of this partition consumer
// when it is consumed. By default, the mock consumer will not verify whether this error was
// consumed from the Errors channel, because there are legitimate reasons for this
// not to happen. You can call ExpectErrorsDrainedOnClose so it will verify that
// the channel is empty on close.
func (pc *PartitionConsumer) YieldError(err error) <span class="cov8" title="1">{
        pc.errors &lt;- &amp;sarama.ConsumerError{
                Topic:     pc.topic,
                Partition: pc.partition,
                Err:       err,
        }
}</span>

// ExpectMessagesDrainedOnClose sets an expectation on the partition consumer
// that the messages channel will be fully drained when Close is called. If this
// expectation is not met, an error is reported to the error reporter.
func (pc *PartitionConsumer) ExpectMessagesDrainedOnClose() <span class="cov0" title="0">{
        pc.messagesShouldBeDrained = true
}</span>

// ExpectErrorsDrainedOnClose sets an expectation on the partition consumer
// that the errors channel will be fully drained when Close is called. If this
// expectation is not met, an error is reported to the error reporter.
func (pc *PartitionConsumer) ExpectErrorsDrainedOnClose() <span class="cov0" title="0">{
        pc.errorsShouldBeDrained = true
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "encoding/json"
        "fmt"
        "os"
        "os/signal"
        "strings"
        "time"

        "gitea-cicd.apps.aws2-dev.ocp.14west.io/cicd/trackmate-message-consumer/pkg/connectors"
        "gitea-cicd.apps.aws2-dev.ocp.14west.io/cicd/trackmate-message-consumer/pkg/schema"
        "github.com/Shopify/sarama"
        gocb "github.com/couchbase/gocb/v2"
        "github.com/segmentio/ksuid"
)

// Init : public function that connects to the kafka queue and redis cache
func Init(conn connectors.Clients) <span class="cov8" title="1">{

        mc := conn.KafkaConsumer()

        defer func() </span><span class="cov8" title="1">{
                if err := mc.Close(); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }()

        <span class="cov8" title="1">topics, _ := mc.Topics()

        consumer, errors := consume(conn, topics, mc)

        signals := make(chan os.Signal, 1)
        signal.Notify(signals, os.Interrupt)

        // Count how many message processed
        msgCount := 0

        // create a chanel for our consumer messages
        doneCh := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case msg := &lt;-consumer:<span class="cov8" title="1">
                                msgCount++
                                conn.Debug(fmt.Sprintf("Received messages %v ", msg))
                                if os.Getenv("TESTING") == "true" &amp;&amp; msgCount &gt; 1 </span><span class="cov0" title="0">{
                                        conn.Info("Test flag set - auto interrupt")
                                        doneCh &lt;- struct{}{}
                                }</span>
                        case consumerError := &lt;-errors:<span class="cov8" title="1">
                                msgCount++
                                conn.Error(fmt.Sprintf("Received consumerError  %v ", consumerError))
                                doneCh &lt;- struct{}{}</span>
                        case &lt;-signals:<span class="cov0" title="0">
                                conn.Info("Interrupt detected")
                                doneCh &lt;- struct{}{}</span>
                        }
                }
        }()

        <span class="cov8" title="1">&lt;-doneCh
        conn.Info(fmt.Sprintf("Processed %d messages", msgCount))</span>
}

// consume function - it iterates through each topic to find the specified topic, once found it then iterates through each partition
func consume(conn connectors.Clients, topics []string, master sarama.Consumer) (chan *sarama.ConsumerMessage, chan *sarama.ConsumerError) <span class="cov8" title="1">{

        conn.Info(fmt.Sprintf("Function consume topics %v", topics))
        consumers := make(chan *sarama.ConsumerMessage)
        errors := make(chan *sarama.ConsumerError)
        for _, topic := range topics </span><span class="cov8" title="1">{
                conn.Info(fmt.Sprintf("iterate topics %v", topics))
                if strings.Contains(topic, "__consumer_offsets") </span><span class="cov0" title="0">{
                        continue</span>
                }
                // We are only interested in the specified topic
                <span class="cov8" title="1">if topic == os.Getenv("TOPIC") </span><span class="cov8" title="1">{
                        partitions, _ := master.Partitions(topic)
                        for x, _ := range partitions </span><span class="cov8" title="1">{
                                // consider using sarama.OffsetNewest
                                consumer, err := master.ConsumePartition(topic, partitions[x], sarama.OffsetOldest)
                                if nil != err </span><span class="cov8" title="1">{
                                        conn.Error(fmt.Sprintf("Topic %v Partition: %v", topic, partitions[x]))
                                        break</span>
                                }
                                <span class="cov8" title="1">conn.Info(fmt.Sprintf("Start consuming topic %v ", topic))
                                go func(topic string, consumer sarama.PartitionConsumer) </span><span class="cov8" title="1">{
                                        for </span><span class="cov8" title="1">{
                                                select </span>{
                                                case consumerError := &lt;-consumer.Errors():<span class="cov8" title="1">
                                                        errors &lt;- consumerError
                                                        conn.Error(fmt.Sprintf("consumerError: %v ", consumerError))</span>

                                                case msg := &lt;-consumer.Messages():<span class="cov8" title="1">
                                                        consumers &lt;- msg
                                                        conn.Debug(fmt.Sprintf("Got message on topic %v : %v ", topic, msg))

                                                        err := postToDB(conn, msg)
                                                        if err != nil </span><span class="cov8" title="1">{
                                                                conn.Error(fmt.Sprintf("Error : %v ", err))
                                                        }</span>
                                                }
                                        }
                                }(topic, consumer)
                        }
                }
        }
        <span class="cov8" title="1">return consumers, errors</span>
}

// postToDB : private utility function that posts the json payload to couchbase
func postToDB(conn connectors.Clients, msg *sarama.ConsumerMessage) error <span class="cov8" title="1">{

        var analytics *schema.SegmentIO
        var temp *schema.NewFormat

        // check if we have the updated detached json from segmentio
        if msg != nil </span><span class="cov8" title="1">{
                payload := string(msg.Value)
                conn.Debug(fmt.Sprintf("Data from message queue %s", payload))

                if strings.Index(payload, "anonymousId") == -1 </span><span class="cov8" title="1">{
                        // we have the new format
                        errs := json.Unmarshal(msg.Value, &amp;temp)
                        if errs != nil </span><span class="cov8" title="1">{
                                conn.Error("postToDB unmarshalling new format %v", errs)
                                return errs
                        }</span>
                        <span class="cov8" title="1">id := ksuid.New()
                        analytics = &amp;schema.SegmentIO{}
                        analytics.Id = id.String()
                        analytics.Context.UserAgent = temp.UserAgent
                        analytics.Properties.Type = temp.Type
                        analytics.Properties.Spec = temp.Spec
                        analytics.Properties.Value = temp.Value
                        analytics.Properties.UtmVariable = temp.UtmVariable
                        now := time.Now()
                        // layout := "2006-01-02T15:04:05Z"
                        analytics.ReceivedAt = now
                        analytics.Timestamp = now
                        analytics.SentAt = now
                        analytics.UserID = "message-consumer-couchbase"
                        analytics.Version = 1131</span>
                } else<span class="cov0" title="0"> {
                        // we first unmarshal the payload and add needed values before posting to couchbase
                        errs := json.Unmarshal(msg.Value, &amp;analytics)
                        if errs != nil </span><span class="cov0" title="0">{
                                conn.Error("postToDB %v\n", errs)
                                return errs
                        }</span>
                }

                //_, err := c.Upsert(analytics.Affiliate+"-"+strconv.FormatInt(analytics.Timestamp, 10), analytics, &amp;gocb.UpsertOptions{})
                // TODO:  we have to make our service idempotent
                <span class="cov8" title="1">_, err := conn.Upsert(analytics.Id, analytics, &amp;gocb.UpsertOptions{})
                if err != nil </span><span class="cov0" title="0">{
                        conn.Error(fmt.Sprintf("Could not upsert schema into couchbase %v", err))
                        return err
                }</span>

                // all good :)
                <span class="cov8" title="1">conn.Info("Analytics schema inserted into couchbase")
                return nil</span>

        } else<span class="cov0" title="0"> {
                conn.Info("Message data is nil")
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package validator

import (
        "fmt"
        "os"
        "strconv"
        "strings"

        "github.com/microlib/simple"
)

// checkEnvars - private function, iterates through each item and checks the required field
func checkEnvar(item string, logger *simple.Logger) error <span class="cov8" title="1">{
        name := strings.Split(item, ",")[0]
        required, _ := strconv.ParseBool(strings.Split(item, ",")[1])
        logger.Trace(fmt.Sprintf("name %s : required %t", name, required))
        if os.Getenv(name) == "" </span><span class="cov8" title="1">{
                if required </span><span class="cov8" title="1">{
                        logger.Error(fmt.Sprintf("%s envar is mandatory please set it", name))
                        return fmt.Errorf(fmt.Sprintf("%s envar is mandatory please set it", name))
                }</span>

                <span class="cov8" title="1">logger.Error(fmt.Sprintf("%s envar is empty please set it", name))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateEnvars : public call that groups all envar validations
// These envars are set via the openshift template
func ValidateEnvars(logger *simple.Logger) error <span class="cov8" title="1">{
        items := []string{
                "LOG_LEVEL,false",
                "SERVER_PORT,true",
                "REDIS_HOST,true",
                "REDIS_PORT,true",
                "REDIS_PASSWORD,true",
                "URL,true",
                "TOKEN,true",
                "VERSION,true",
                "KAFKA_BROKERS,true",
                "TOPIC,true",
                "CONNECTOR,true",
        }
        for x := range items </span><span class="cov8" title="1">{
                if err := checkEnvar(items[x], logger); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
